---
title: С чего начать
description: 
published: true
date: 2024-03-07T14:06:44.950Z
tags: 
editor: markdown
dateCreated: 2024-03-07T14:06:44.950Z
---

# Что это вообще такое?
Если вкратце - это способ описания приоритетов для принятия решений роботом, NPC да и в принципе кем/чем угодно.
Деревья поведения это довольно известная в гейм-деве штука и уже лет больше десятка лет используются в самых-самых разных проектах для написания ИИ. 
Да, есть как более сложные, так и более гибкие технологии, но деревья остаются одним из самых распространенных вариантов в силу своей относительной простоты. Разобраться сходу не особо просто, но, к счастью, материалов в интернете навалом и никаких проблем с гайдами нет. 

# Как они связаны с Eye Auras?
Практически с самых первых дней в программе была система триггеров и действий как способ настройки реакций на что-либо - появление иконки на экране, сворачивание/разворачивание окон и т.п. Что-то происходит (= триггер активируется) - программа на это реагирует и выполняет действие. Такой подход работает хорошо, но лишь для достаточно простых условий - как только в условие намешиваются какие-то дополнительные моменты, конфигурация очень быстро выходит из-под контроля и становится очень-очень сложно понять, что происходит и как это починить. При этом инструменты, которые я добавлял, к примеру, [граф зависимостей](https://wiki.eyeauras.net/en/overlays/dependencies-viewer)
![dependencies graph](https://wiki.eyeauras.net/eyeauras_gksfvq7xla[1].png)

лишь боролись с симптомами, а сама проблема оставалась на месте - триггеры/действия просто не приспособлены для моделирования многоуровневой логики, к примеру, ротацию скиллов сделать можно, но довольно сложно.

И вот здесь-то и пришли на помощь те самые деревья - они достаточно простые в настройке, гибкие и доказанно эффективные, так как на базе них трудится бесчисленное количество настоящих роботов и ботов в играх. 

# Как они работают?
Для начала давайте вспомним, что в EyeAuras у нас есть триггеры и действия. Одни реагируют на что-то и бывают активированы и деактивированы. Вторые делают что-то. Тут все понятно, ничего нового. А теперь представьте себе, что это две абсолютно независимых вещи - триггеры лишь отслеживают **события** (к примеру, появление бафа/дебафа, падение уровня HP ниже нормы и т.п.), ну а действия остаются прежними, просто мы перестаем их связывать с триггерами старым образом - никакого добавления их в OnEnter/WhileActive/OnExit, они просто живут сами по себе. 

Все, что нам остается сделать это как-то связать **события** и **действия** вместе. И дерево позволяет сделать **ровно** это - указать что именно нужно делать, если что-то произошло. 

Деревья всегде начинаются с корня и состоят из узлов, они же ноды. Каждая нода может быть:
- действием - тут все просто, нода умеет что-то делать
- условием - уже сложнее, условия могут быть самые-самые разные, задача такой ноды вернуть true/false. Очень похоже на то, что делают триггеры - проверяют условие и активируются/деактивируются
- декоратором - сами по себе эти ноды ничего не умеют, но они могут менять результаты выполнения других нод, к примеру, сделать инверсию и превратить **true** в **false** (или наоборот)

![behavior tree visualization](https://habrastorage.org/files/5f3/cdb/96b/5f3cdb96beee450ca78697a67010b8e9.gif)

(изображение взято отсюда, статья на русском языке - https://habr.com/ru/companies/cloud_mts/articles/306214/