---
title: 3. Составные части
description: 
published: true
date: 2025-05-11T13:41:03.732Z
tags: 
editor: markdown
dateCreated: 2025-05-11T01:13:28.765Z
---

# Составные части
Когда вы добавили новый оверлей, автоматически были созданы и добавлены несколько файлов, каждый из которых очень важен для программы.
![Header](https://s3.eyeauras.net/media/2025/05/NVIDIA_Overlay_uPjkmxmv2r.png)

## Script.csx
Этот файл - входная точка. Каждый раз, когда программа **создает** новый оверлей (именно **создает**, а не **показывает/скрывает**!), будет вызываться этот скрипт.
В целом в нем может вообще не быть никакого кода, помимо того, который приведен для примера, однако в каких-то случаях здесь вы можете инициализировать данный, считать какую-то информацию и т.п. Это все можно сделать и в коде окна/компонентов, но иногда удобно иметь вот такую общую точку.
```csharp
Log.Debug("This script is entry point for Overlay");
```

---

## UserOverlay.cs
```csharp
public partial class UserOverlay : BlazorReactiveComponent {
    private int count = 0;

    private void IncrementCount()
    {
        count++;
    }
}
```
Это так называемый **code-behind** файл. Большинство Razor-компонентов состоят из двух частей - `*.razor` и `*.cs`. В Razor-части обычно содержится Razor/HTML/CSS-разметка, а в `*.cs` - методы, поля и свойства, к которым разметка мможет обращаться. 
> Важно! В `*.razor` файле можно писать и C# код, тогда мы можете обойтись совсем без `*.cs`. Однако, в силу технических ограничей, **EyeAuras** пока умеет отображать авто-дополнение только в `*.cs` файлах, поэтому рекомендуется иметь все-таки два файла.
{.is-info}

Разберем код
```csharp 
public partial class UserOverlay : BlazorReactiveComponent
```
Объявление класса. Все части важны - чтобы EyeAuras корректно мог найти ваш класс, он должен быть `public`. При этом так как у него есть вторая составная часть (`*.razor`), он должен быть `partial`, что говорит о том, что данный класс `UserOverlay` состоит из нескольких (*скольки-то*) частей. 
Ну и финальная часть, `: BlazorReactiveComponent` говорит о том, какой базовый класс использовать. Об этом будет чуть ниже.

```csharp
private int count = 0;
```
Объявляем поле, в котором будет храниться сколько раз мы кликнули на кнопку. 
> Важно! Обратите внимание, что на протяжении всего жизни оверлея, это поле не будет сброшено. Однако если вдруг аура будет выгружена или оверлей будет разрушен по любой другой причине, значение в этом поле будет стерто

```csharp
private void IncrementCount()
    {
        count++;
    }
```
Этот метод просто увеличивает значение счетчика. Именно с его помощью мы будем контролировать нажатия.

---

## UserOverlay.razor
```html
@inherits BlazorReactiveComponent

<h3 class="text-center">Interactive Counter</h3>

<div class="text-center mt-4">
    <button @onclick="IncrementCount" class="btn btn-primary btn-lg">
        Click Me
    </button>
</div>

<p class="text-center mt-3" style="font-size: 1.5rem;">
    You clicked <strong>@count</strong> times!
</p>
```
Вторая часть нашего первого компонента, которая содержит в себе уже описание того, как именно отрисовывать наш компонент. Давайте разберем чуть подробнее что у нас здесь есть:
```html 
@inherits BlazorReactiveComponent
```
Эта строка говорит "В качестве базового класса используй BlazorReactiveComponent", который является частью **EyeAuras**. Это не обязательно, но я крайне рекомендую использовать в качетсве базового класса именно `BlazorReactiveComponent` - это расширит доступный вам функционал. 

```html
<h3 class="text-center">Interactive Counter</h3>
```
Ничего интересного - отображаем центрированную строчку

```html
<div class="text-center mt-4">
    <button @onclick="IncrementCount" class="btn btn-primary btn-lg">
        Click Me
    </button>
</div>
```
А вот здесь уже есть один интересный момент - в `@onclick` мы указываем обработчик нажатия `IncrementCount`, тот самый, который увеличивает счетчик. 
В результате, при каждом нажатии мы будем увеличивать переменную `count` на `1`

```html
<p class="text-center mt-3" style="font-size: 1.5rem;">
    You clicked <strong>@count</strong> times!
</p>
```
Финальный кусочек паззла. Здесь мы отрисовываем текущее значение переменной (`@count`). Той самой, которую мы увеличиваем при нажатии на кнопку.

---

Итак, в результате у нас получилась простенькая форма, в которой есть кнопка и обновляемое значение. 
Вот так буквально в 20 строк мы получили вполне работающую и даже местами симпатичную программу. Вы можете поиграться с цветами, попробовать добавить какие-то еще значения и в целом использовать этот оверлей как площадку для тестов. Дальше - больше!
